/** @flow */
import sequest from 'sequest';

// import ComponentObjects from '../../component-objects';
import {
  RemoteScopeNotFound,
  NetworkError,
  UnexpectedNetworkError,
  PermissionDenied,
  ComponentNotFound } from './exceptions';

// import { BitIds, BitId } from '../../../bit-id';
// import ConsumerComponent from '../../../consumer/component'; // TODO a way to serialze output

type SSHUrl = {
  username: string,
  port: number,
  host: string,
  path: ?string
};

////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// start componentObjects component //////////////////
////////////////////////////////////////////////////////////////////////////////////

const ComponentObjects = null // TODO

////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// end componentObjects component ////////////////////
////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// start pack component //////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

const pack = () => null // TODO

////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// end pack component ////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// start unpack component ////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

const unpack = () => null // TODO

////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// end unpack component //////////////////////////////
////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// start to base64 component /////////////////////////
////////////////////////////////////////////////////////////////////////////////////

const toBase64 = (x:string|Buffer): ?string => null // TODO

////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// end to base64 component ///////////////////////////
////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// start from base64 component ///////////////////////
////////////////////////////////////////////////////////////////////////////////////

const fromBase64 = (x:string|Buffer): ?string => null // TODO

////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// end from base64 component /////////////////////////
////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// start is number component /////////////////////////
////////////////////////////////////////////////////////////////////////////////////

const isNumber = x => typeof x === 'number';

////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// end is number component ///////////////////////////
////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// start is string component /////////////////////////
////////////////////////////////////////////////////////////////////////////////////

const isString = x => typeof x === 'string';

////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// end is string component /???///////////////////////
////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// start key getter component ////////////////////////
////////////////////////////////////////////////////////////////////////////////////

const userHome = require('user-home');
const fs = require('fs');
const path = require('path');

function getDirectory(): string {
  if (process.platform === 'win32' && process.env.LOCALAPPDATA) {
    return path.join(process.env.LOCALAPPDATA, 'Bit');
  }

  return path.join(userHome, '.bit');
}

function getCacheDirectory(): string {
  if (process.platform === 'darwin') {
    return path.join(userHome, 'Library', 'Caches', 'Bit');
  }

  return getDirectory();
}

const CACHE_ROOT = getCacheDirectory();
const GLOBAL_CONFIG = path.join(CACHE_ROOT, 'config');
const GLOBAL_CONFIG_FILE = 'config.json';

function getPath() {
  return path.join(GLOBAL_CONFIG, GLOBAL_CONFIG_FILE);
}

class GlobalConfig {
  config: Object;

  constructor(config) {
    this.config = config;
  }

  get(key: string): ?string {
    if (this.config[key]) {
      return this.config[key];
    }

    return null;
  }

  toString() {
    return JSON.stringify(this.config);
  }

  static fromString(str: string): Object {
    if (!isString(str)) {
      throw new Error(`invalid type to from string function, type should be string instead it is ${typeof str}`)
    }

    return new GlobalConfig(JSON.parse(str));
  }

  static loadSync(): GlobalConfig {
    try {
      const contents = fs.readFileSync(getPath()).toString();
      return this.fromString(contents);
    } catch (err) {
      if (err.code !== 'ENOENT') return err;
      return new GlobalConfig({});
    }
  }
}

function getSync(key: string): ?string {
  const config = GlobalConfig.loadSync();
  return config.get(key);
}

const CFG_SSH_KEY_FILE_KEY = 'ssh_key_file';
const DEFAULT_SSH_KEY_FILE = `${userHome}/.ssh/id_rsa`;

function getPathToIdentityFile() {
  const identityFile = getSync(CFG_SSH_KEY_FILE_KEY);
  return identityFile || DEFAULT_SSH_KEY_FILE;
}

function keyGetter(keyPath: ?string) {
  if (keyPath) return fs.readFileSync(keyPath);
  return fs.readFileSync(getPathToIdentityFile());
}

////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// end key getter component /////////////////////////////
////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// start ssh url parser /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

/**
 * @credit taken from mikeal/sequest and modified
 * to include path and protocol prefix parsing.
 */
function parseSSHUrl(str: string): SSHUrl {
  let user = 'root';
  let port = 22;
  let path = null;
  if (str.startsWith('ssh://')) str = str.replace('ssh://', '');
  if (str.startsWith('bit://')) str = str.replace('ssh://', '');

  if (str.indexOf('@') !== -1) {
    user = str.slice(0, str.indexOf('@'));
    str = str.slice(str.indexOf('@') + 1);
  }
  if (str.indexOf(':') !== -1) {
    const [potentialPort, potentialPath] = str
      .slice(str.indexOf(':') + 1)
      .split(':');

    const maybePort = parseInt(potentialPort);
    if (!isNaN(maybePort) && isNumber(maybePort)) {
      port = maybePort;
      if (potentialPath) path = potentialPath;
    }

    if (!potentialPath && isNaN(maybePort)) {
      path = potentialPort;
    }

    str = str.slice(0, str.indexOf(':'));
  }
  const host = str;

  return {
    host,
    path,
    port,
    username: user
  };
}

////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// end ssh url parser ///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// start absolute path component ////////////////////////
////////////////////////////////////////////////////////////////////////////////////

function absolutePath(path: string) {
  if (!path.startsWith('/')) return `~/${path}`;
  return path;
}

////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// end absolute path component //////////////////////////
////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// start clean new lines component //////////////////////
////////////////////////////////////////////////////////////////////////////////////

function cleanNewLines(str: string) {
  return str.replace('\n', '');
}

////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// end clean new lines component ////////////////////////
////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// start ssh scope error handler ////////////////////////
////////////////////////////////////////////////////////////////////////////////////

function errorHandler(err, optionalId) {
  return err;
  // switch (err.code) {
  //   default:
  //     return new UnexpectedNetworkError();
  //   case 127:
  //     return new ComponentNotFound(err.id || optionalId);
  //   case 128:
  //     return new PermissionDenied();
  //   case 129:
  //     return new RemoteScopeNotFound();
  //   case 130:
  //     return new PermissionDenied();
  // }
}

////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// end ssh scope error handler //////////////////////////
////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// start scope ssh client ///////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

type SSHProps = {
  path: ?string,
  username: string,
  port: number,
  host: string
};

/**
 * an ssh client for consuming bit components from a remote scope
 * @param {type} name
 * @returns {type}
 * @example
 */
module.exports = class ScopeSSHClient {
  connection: any;
  path: ?string;
  username: string;
  port: number;
  host: string;

  constructor({ path, username, port, host }: SSHProps) {
    this.path = path;
    this.username = username;
    this.port = port;
    this.host = host || '';
  }

  buildCmd(commandName: string, ...args: string[]): string {
    function serialize() {
      return args
        .map(val => toBase64(val))
        .join(' ');
    }

    return `bit ${commandName} ${serialize()}`;
  }

  exec(commandName: string, ...args: any[]): Promise<any> {
    return new Promise((resolve, reject) => {
      const cmd = this.buildCmd(commandName, absolutePath(this.path || ''), ...args);
      this.connection(cmd, function (err, res, o) {
        if (!o) return reject(UnexpectedNetworkError);
        if (err && o.code && o.code !== 0) return reject(errorHandler(err, res));
        return resolve(cleanNewLines(res));
      });
    });
  }

  fetch(ids: BitIds, noDeps: bool = false): Promise<ComponentObjects[]> {
    let options = '';
    ids = ids.map(bitId => bitId.toString());
    if (noDeps) options = '-n';
    return this.exec(`_fetch ${options}`, ...ids)
      .then((str: string) => {
        const components = unpack(str);
        return components.map((raw) => {
          return ComponentObjects.fromString(raw);
        });
      });
  }

  close() {
    this.connection.end();
    return this;
  }

  composeConnectionUrl() {
    return `${this.username}@${this.host}:${this.port}`;
  }

  connect(sshUrl: SSHUrl, key: ?string): Promise<ScopeSSHClient> {
    this.connection = sequest.connect(this.composeConnectionUrl(), {
      privateKey: keyGetter(key)
    });

    return Promise.resolve(this);
  }

  static fromUrl(url: string): ScopeSSHClient {
    return new ScopeSSHClient(parseSSHUrl(url));
  }
};

////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// end scope ssh client /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
